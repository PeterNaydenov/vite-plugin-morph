/**
 * ES module generation utilities
 * @fileoverview Generates final ES module code from processing results
 * @author Peter Naydenov
 * @version 1.0.0
 */

import { debug } from '../utils/logger.js';
import { isProductionMode } from '../utils/shared.js';

/**
 * Generate ES module code from processing result
 * @param {import('./types/processing.js').ProcessingResult} result - Processing result
 * @param {import('./types/plugin.js').MorphPluginOptions} options - Plugin options
 * @returns {string} Generated ES module code
 */
export function generateESModule(result, options) {
  const parts = [];

  // Add file header comment
  parts.push(
    `// Generated by vite-plugin-morph from ${result.metadata?.filePath || 'unknown'}`
  );
  parts.push(`// Generated at: ${new Date().toISOString()}`);
  parts.push(`// Processing time: ${result.metadata?.processingTime || 0}ms`);
  parts.push('');

  // Add CSS exports if present
  if (result.cssExports && Object.keys(result.cssExports).length > 0) {
    parts.push('// CSS module exports');
    parts.push(
      `export const styles = ${JSON.stringify(result.cssExports, null, 2)};`
    );
    parts.push('');
  }

  // Add handshake in development mode
  if (result.metadata?.components?.handshake && !isProductionMode(options)) {
    parts.push('// Handshake data (development only)');
    parts.push(
      `export const handshake = ${JSON.stringify(result.handshakeData, null, 2)};`
    );
    parts.push('');
  }

  // Add render function export with context preservation
  if (result.renderFunction) {
    parts.push('// Import morph utilities');
    parts.push("import morph from '@peter.naydenov/morph';");
    parts.push("const originalChop = morph.get(['chop']);");
    parts.push(
      "const safeChop = (() => { const safe = {}; for (const [key, value] of Object.entries(originalChop)) { if (typeof value === 'function') continue; safe[key] = value; } return safe; })();"
    );

    // Serialize helper functions if present
    const helpers = result.metadata?.helperFunctions || [];
    const serializedHelpers = {};
    for (const name of helpers) {
      // Note: We need access to actual function objects here, this is a simplified version
      // In practice, we'd need to pass the actual helper functions from the processing result
      serializedHelpers[name] = `function ${name}() { /* Helper function */ }`;
    }

    // Create context object
    const contextData = {
      chop: {},
      helpers: serializedHelpers,
      handshake: result.handshakeData || null,
      placeholders: [],
    };

    parts.push(
      'const morphRenderFunction = ' + result.renderFunction.toString() + ';'
    );
    parts.push('const reconstructedHelpers = {};');
    for (const name of Object.keys(serializedHelpers)) {
      parts.push(
        `try { reconstructedHelpers['${name}'] = new Function('return ' + ${JSON.stringify(serializedHelpers[name])})(); } catch(e) { console.warn('Failed to reconstruct helper ${name}:', e); }`
      );
    }
    // Inline all context variables for morphRenderFunction scope
    parts.push('// Inline context variables from _readTemplate');
    parts.push('const chop = originalChop;');
    parts.push('const helpers = reconstructedHelpers;');
    parts.push(
      'const handshake = ' +
        (contextData.handshake ? JSON.stringify(contextData.handshake) : '{}') +
        ';'
    );
    parts.push(
      'let placeholders = ' + JSON.stringify(contextData.placeholders) + ';'
    );
    parts.push(
      'const originalPlaceholders = ' +
        JSON.stringify(contextData.placeholders) +
        ';'
    );
    parts.push('const buildDependencies = {};');
    parts.push('const snippets = {};');

    // Add internal morph helper functions
    parts.push('// Internal morph helper functions');
    parts.push('const _defineDataType = (data) => {');
    parts.push("  if (data === null || data === undefined) return 'null';");
    parts.push("  if (Array.isArray(data)) return 'array';");
    parts.push("  if (typeof data === 'object') return 'object';");
    parts.push("  return 'primitive';");
    parts.push('};');

    parts.push('const _defineData = (info, action) => {');
    parts.push('  const dataDeepLevel = [];');
    parts.push('  const nestedData = [];');
    parts.push('  // Process data and actions to determine nesting');
    parts.push(
      '  // Implementation would be complex - using simplified version'
    );
    parts.push('  return { dataDeepLevel, nestedData };');
    parts.push('};');

    parts.push('const _setupActions = (actions, dataDeepLevel) => {');
    parts.push('  // Simplified action setup');
    parts.push(
      '  return actions.map(action => ({ type: action, name: action, level: dataDeepLevel }));'
    );
    parts.push('};');

    parts.push('const _actionSupply = (actSetup, dataDeepLevel) => {');
    parts.push('  // Simplified action supply');
    parts.push('  return actSetup;');
    parts.push('};');

    parts.push('const walk = ({data, objectCallback}) => {');
    parts.push('  // Simplified walk function');
    parts.push('  return data;');
    parts.push('};');
    parts.push('// Render function with inlined context');
    parts.push(
      "export default function(command = 'render', data = {}, dependencies = {}, ...args) {"
    );
    parts.push('  return morphRenderFunction(command, data, dependencies);');
    parts.push('};');
  } else {
    parts.push('// No render function (CSS-only file)');
  }

  // Add source map reference if enabled
  if (options.development?.sourceMaps && result.map) {
    parts.push('');
    parts.push('//# sourceMappingURL=' + result.map.file);
  }

  return parts.join('\n');
}

/**
 * Generate CSS-only module code
 * @param {Record<string,string>} cssExports - CSS exports
 * @param {import('./types/plugin.js').MorphPluginOptions} options - Plugin options
 * @returns {string} Generated ES module code
 */
export function generateCSSOnlyModule(cssExports, options) {
  const parts = [];

  // Add file header comment
  parts.push(`// Generated by vite-plugin-morph (CSS-only module)`);
  parts.push(`// Generated at: ${new Date().toISOString()}`);
  parts.push('');

  // Add CSS exports
  parts.push('// CSS module exports');
  parts.push(`export const styles = ${JSON.stringify(cssExports, null, 2)};`);
  parts.push('');

  // Add source map reference if enabled
  if (options.development?.sourceMaps) {
    parts.push('');
    parts.push('//# sourceMappingURL=styles.js.map');
  }

  return parts.join('\n');
}

/**
 * Validate generated module code
 * @param {string} code - Generated code
 * @returns {boolean} Whether code is valid
 */
export function validateGeneratedCode(code) {
  try {
    // Basic syntax check
    new Function(code);
    return true;
  } catch (error) {
    debug(`Generated code validation failed: ${error.message}`);
    return false;
  }
}

/**
 * Create module metadata
 * @param {import('./types/processing.js').ProcessingResult} result - Processing result
 * @returns {Object} Module metadata
 */
export function createModuleMetadata(result) {
  return {
    type: result.isCSSOnly ? 'css-module' : 'morph-component',
    hasCSS: !!result.cssExports,
    hasTemplate: !!result.renderFunction,
    hasHandshake: !!result.handshakeData,
    processingTime: result.metadata?.processingTime || 0,
    fileSize: Buffer.byteLength(result.code || '', 'utf8'),
    generatedAt: new Date().toISOString(),
  };
}
