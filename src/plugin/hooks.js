/**
 * Vite plugin hooks implementation
 * @fileoverview Implements transform and HMR hooks for .morph files
 * @author Peter Naydenov
 * @version 0.0.10
 */

import { createMorphError } from '../core/errors.js';
import { processMorphFile } from '../core/processor.js';
import { debug, info, error } from '../utils/logger.js';
import { composeComponents } from '../core/composer.js';
import { generateThemeCSS } from '../core/themer.js';
import { watchFiles } from '../utils/file-watcher.js';

/**
 * Transform hook for .morph files
 * @param {string} code - File content
 * @param {string} id - File path
 * @param {import('vite').TransformOptions} [options] - Vite transform options
 * @returns {Promise<import('../../types/index.d.ts').TransformResult>} Transform result
 */
export async function transformHook(code, id, options = {}) {
  // Only process .morph files
  if (!id || !id.endsWith('.morph')) return null;

  // Validate inputs
  if (typeof code !== 'string') {
    throw new Error(
      `Invalid code parameter: expected string, got ${typeof code}`
    );
  }
  if (typeof id !== 'string') {
    throw new Error(`Invalid id parameter: expected string, got ${typeof id}`);
  }

  // Debug logging for troubleshooting
  console.log(
    '[vite-plugin-morph] Processing morph file:',
    id,
    'code length:',
    code?.length || 0
  );
  console.log(
    '[vite-plugin-morph] File content preview:',
    code?.substring(0, 200) + '...'
  );

  // Get plugin options from Vite config
  const pluginOptions = getPluginOptions(options);

  try {
    // Process the morph file
    const result = await processMorphFile(code, id, pluginOptions);

    // Validate result before returning
    if (!result || typeof result.code !== 'string') {
      throw new Error(
        `processMorphFile returned invalid result: ${JSON.stringify(result)}`
      );
    }

    // Check if processing resulted in errors
    if (result.errors && result.errors.length > 0) {
      // Return error in meta for tests to inspect
      return {
        code: `// Processing Error: ${result.errors[0].message}`,
        map: null,
        meta: {
          'vite-plugin-morph': {
            type: 'morph',
            errors: result.errors,
            processingTime: result.processingTime,
            isCSSOnly: false,
          },
        },
      };
    }

    // Ensure code is always a valid string
    const safeCode =
      typeof result.code === 'string'
        ? result.code
        : '// Error: Invalid code generated by morph plugin';

    // Create transform result
    const transformResult = {
      code: safeCode,
      map: result.map,
      meta: {
        'vite-plugin-morph': {
          type: 'morph',
          warnings: result.warnings || [],
          processingTime: result.processingTime,
          isCSSOnly: result.isCSSOnly || false,
        },
      },
    };

    info(`Successfully transformed ${id} in ${result.processingTime}ms`);
    return transformResult;
  } catch (err) {
    // Ensure error has a valid message
    const errorMessage =
      err?.message || err?.toString() || 'Unknown error occurred';
    const safeId = id || 'unknown-file';

    error(`Transform failed for ${safeId}: ${errorMessage}`);

    // Create error with location information
    const morphError = createMorphError(
      err && typeof err === 'object' ? err : new Error(errorMessage),
      safeId,
      null,
      'TRANSFORM_ERROR'
    );

    // Ensure morphError has a valid message
    const safeErrorMessage = morphError?.message || 'Transform failed';

    // Return error in meta for tests to inspect
    return {
      code: `// Transform Error: ${safeErrorMessage}`,
      map: null,
      meta: {
        'vite-plugin-morph': {
          type: 'morph',
          errors: [morphError].filter(Boolean),
          processingTime: 0,
          isCSSOnly: false,
        },
      },
    };
  } // catch
} // transformHook func.

/**
 * Handle hot module replacement for .morph files
 * @param {import('vite').HmrContext} context - HMR context
 * @returns {Promise<import('vite').HmrResult|null>} HMR result
 */
export async function handleHotUpdate(context) {
  if (!context.file.endsWith('.morph')) {
    return null;
  }

  try {
    debug(`Handling HMR for ${context.file}`);

    // Read the updated file content
    const code = await context.read();

    // Get plugin options
    const pluginOptions = getPluginOptions(context.server.config);

    // Process the updated file
    const result = await processMorphFile(code, context.file, pluginOptions);

    // Create HMR updates
    const updates = [];

    // Update the main module
    updates.push({
      type: 'js-update',
      path: context.file,
      timestamp: context.timestamp,
    });

    // If CSS is present, also update CSS
    if (result.cssExports) {
      updates.push({
        type: 'css-update',
        path: `${context.file}.css`,
        timestamp: context.timestamp,
      });
    }

    // Handle composition updates
    if (pluginOptions.composition?.enabled && result.composition) {
      updates.push({
        type: 'js-update',
        path: `${context.file}.composition`,
        timestamp: context.timestamp,
      });
    }

    // Handle theme updates
    if (pluginOptions.themes?.enabled && result.themeData) {
      updates.push({
        type: 'css-update',
        path: `${context.file}.theme.css`,
        timestamp: context.timestamp,
      });
    }

    // Send updates to client
    if (context.server && context.server.ws) {
      context.server.ws.send({
        type: 'update',
        updates,
      });
    }

    info(`HMR update sent for ${context.file}`);

    return {
      modules: context.modules,
      updates,
    };
  } catch (err) {
    error(`HMR failed for ${context.file}: ${err.message}`);

    // Send error to client
    if (context.server && context.server.ws) {
      context.server.ws.send({
        type: 'error',
        err: {
          message: err.message,
          file: context.file,
          timestamp: context.timestamp,
        },
      });
    }

    return null;
  }
}

/**
 * Enhanced transform hook with composition and theme support
 * @param {string} code - File content
 * @param {string} id - File path
 * @param {import('vite').TransformOptions} [options] - Vite transform options
 * @returns {Promise<import('../../types/index.d.ts').TransformResult>} Transform result
 */
export async function enhancedTransformHook(code, id, options = {}) {
  // Only process .morph files
  if (!id || !id.endsWith('.morph')) return null;

  // Validate inputs
  if (typeof code !== 'string') {
    throw new Error(
      `Invalid code parameter: expected string, got ${typeof code}`
    );
  }
  if (typeof id !== 'string') {
    throw new Error(`Invalid id parameter: expected string, got ${typeof id}`);
  }

  // Get plugin options from Vite config
  const pluginOptions = getPluginOptions(options);

  try {
    // Process the morph file
    const result = await processMorphFile(code, id, pluginOptions);

    // Handle composition if enabled
    if (pluginOptions.composition?.enabled && result.componentData) {
      const compositionResult = await composeComponents(result.componentData, {
        maxDepth: pluginOptions.composition.maxDepth,
        allowCircular: pluginOptions.composition.allowCircular,
      });

      result.composition = compositionResult;
    }

    // Handle theme generation if enabled
    if (pluginOptions.themes?.enabled && result.themeData) {
      const themeCSS = await generateThemeCSS(result.themeData, {
        outputDir: pluginOptions.themes.outputDir,
        defaultTheme: pluginOptions.themes.defaultTheme,
      });

      result.themeCSS = themeCSS;
    }

    // Validate result before returning
    if (!result || typeof result.code !== 'string') {
      throw new Error(
        `processMorphFile returned invalid result: ${JSON.stringify(result)}`
      );
    }

    // Check if processing resulted in errors
    if (result.errors && result.errors.length > 0) {
      return {
        code: `// Processing Error: ${result.errors[0].message}`,
        map: null,
        meta: {
          'vite-plugin-morph': {
            type: 'morph',
            errors: result.errors,
            processingTime: result.processingTime,
            isCSSOnly: false,
            composition: result.composition,
            themeCSS: result.themeCSS,
          },
        },
      };
    }

    // Ensure code is always a valid string
    const safeCode =
      typeof result.code === 'string'
        ? result.code
        : '// Error: Invalid code generated by morph plugin';

    // Create transform result
    const transformResult = {
      code: safeCode,
      map: result.map,
      meta: {
        'vite-plugin-morph': {
          type: 'morph',
          warnings: result.warnings || [],
          processingTime: result.processingTime,
          isCSSOnly: result.isCSSOnly || false,
          composition: result.composition,
          themeCSS: result.themeCSS,
        },
      },
    };

    info(`Successfully transformed ${id} in ${result.processingTime}ms`);
    return transformResult;
  } catch (err) {
    // Ensure error has a valid message
    const errorMessage =
      err?.message || err?.toString() || 'Unknown error occurred';
    const safeId = id || 'unknown-file';

    error(`Transform failed for ${safeId}: ${errorMessage}`);

    // Create error with location information
    const morphError = createMorphError(
      err && typeof err === 'object' ? err : new Error(errorMessage),
      safeId,
      null,
      'TRANSFORM_ERROR'
    );

    // Ensure morphError has a valid message
    const safeErrorMessage = morphError?.message || 'Transform failed';

    // Return error in meta for tests to inspect
    return {
      code: `// Transform Error: ${safeErrorMessage}`,
      map: null,
      meta: {
        'vite-plugin-morph': {
          type: 'morph',
          errors: [morphError].filter(Boolean),
          processingTime: 0,
          isCSSOnly: false,
        },
      },
    };
  }
}

/**
 * Get plugin options from Vite config
 * @param {import('vite').ResolvedConfig|import('vite').TransformOptions} configOrOptions - Vite config or transform options
 * @returns {import('../../types/index.d.ts').MorphPluginOptions} Plugin options
 */
function getPluginOptions(configOrOptions) {
  // Handle both ResolvedConfig and TransformOptions
  const config = configOrOptions.config || configOrOptions;

  // Check if this is a direct options object (like in tests)
  if (config && (config.production || config.development)) {
    return config;
  }

  if (!config || !config.plugins) {
    return {
      development: {
        sourceMaps: false,
        hmr: false,
      },
      production: {
        removeHandshake: true,
        minifyCSS: true,
      },
    };
  }

  // Find our plugin in plugins array
  const morphPlugin = config.plugins.find(
    (plugin) =>
      plugin &&
      (plugin.name === 'vite-plugin-morph' || plugin.name === 'morphPlugin')
  );

  return morphPlugin ? morphPlugin.options || {} : {};
}
